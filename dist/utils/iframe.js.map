{"version":3,"file":"iframe.js","sourceRoot":"","sources":["../../src/utils/iframe.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,SAAS,CACvB,EAA+B;IAE/B,OAAO,CAAC,MAAc,EAAE,EAAE,CAAC,EAAE,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;AACzD,CAAC;AAED,MAAM,wBAAwB,GAAgC;IAC5D,OAAO,EAAE,IAAI;IACb,QAAQ,EAAE,KAAK;CAChB,CAAC;AAEF,MAAM,SAAS,GAAG,8CAA8C,CAAC;AAEjE,MAAM,mBAAmB,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAE/C;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,GAAW;IACzC,IAAI,GAAG,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;QACxE,+DAA+D;QAC/D,0BAA0B;QAC1B,4DAA4D;QAC5D,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,0EAA0E;IAC1E,2EAA2E;IAC3E,gDAAgD;IAEhD,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;IAEnC,MAAM,WAAW,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxC,IAAI,QAAgB,CAAC;IACrB,IAAI,QAAgB,CAAC;IACrB,IAAI,IAAY,CAAC;IAEjB,IAAI,WAAW,EAAE,CAAC;QAChB,6CAA6C;QAC7C,6DAA6D;QAC7D,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAC/D,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;IACxB,CAAC;SAAM,CAAC;QACN,yDAAyD;QACzD,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;QAC7B,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;QAC7B,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;IACvB,CAAC;IAED,4FAA4F;IAC5F,gDAAgD;IAEhD,MAAM,UAAU,GACd,IAAI,IAAI,IAAI,KAAK,wBAAwB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IACxE,OAAO,GAAG,QAAQ,KAAK,QAAQ,GAAG,UAAU,EAAE,CAAC;AACjD,CAAC;AAED,MAAM,UAAU,QAAQ;IACtB,OAAO,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;AAC5E,CAAC","sourcesContent":["export function normalize<Promise>(\n  fn: (origin: string) => Promise,\n): (origin: string) => Promise {\n  return (origin: string) => fn(normalizeOrigin(origin));\n}\n\nconst DEFAULT_PORT_BY_PROTOCOL: { [index: string]: string } = {\n  \"http:\": \"80\",\n  \"https:\": \"443\",\n};\n\nconst URL_REGEX = /^(https?:|capacitor:)?\\/\\/([^/:]+)?(:(\\d+))?/;\n\nconst opaqueOriginSchemes = [\"file:\", \"data:\"];\n\n/**\n * Converts a src value into an origin.\n */\nexport function normalizeOrigin(src: string): string {\n  if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return \"null\";\n  }\n\n  // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n\n  const location = document.location;\n\n  const regexResult = URL_REGEX.exec(src);\n  let protocol: string;\n  let hostname: string;\n  let port: string;\n\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  }\n\n  // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n\n  const portSuffix =\n    port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : \"\";\n  return `${protocol}//${hostname}${portSuffix}`;\n}\n\nexport function isIframe() {\n  return typeof window !== \"undefined\" ? window.top !== window.self : false;\n}\n"]}