{"version":3,"file":"generated.js","sourceRoot":"","sources":["../../../../src/utils/api/indexer/generated.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAA2C,MAAM,aAAa,CAAC;AAClG,OAAO,EAAE,YAAY,EAAE,MAAM,WAAW,CAAC;AAkLzC,MAAM,CAAC,MAAM,cAAc,GAAG;;;;;;;;;;;;;;;;;;KAkBzB,CAAC;AACN,MAAM,CAAC,MAAM,cAAc,GAAG,CAIxB,SAA+B,EAC/B,OAAqD,EACrD,EAAE,CACJ,QAAQ,CACN,CAAC,QAAQ,EAAE,SAAS,CAAC,EACrB,YAAY,CAAoC,cAAc,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,EACrF,OAAO,CACR,CAAC;AACN,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAIhC,SAA+B,EAC/B,OAA6D,EAC7D,EAAE;IACJ,MAAM,KAAK,GAAG,YAAY,CAAoC,cAAc,CAAC,CAAA;IAC7E,OAAO,gBAAgB,CACrB,CAAC,iBAAiB,EAAE,SAAS,CAAC,EAC9B,CAAC,QAAQ,EAAE,EAAE,CAAC,KAAK,CAAC,EAAC,GAAG,SAAS,EAAE,GAAG,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE,CAAC,EAAC,CAAC,EAClE,OAAO,CACR,CAAA;AAAA,CAAC,CAAC;AAEP,MAAM,CAAC,MAAM,sBAAsB,GAAG;;;;;;;;;;;;;;;;;;;;;;KAsBjC,CAAC;AACN,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAIhC,SAAuC,EACvC,OAA6D,EAC7D,EAAE,CACJ,QAAQ,CACN,CAAC,gBAAgB,EAAE,SAAS,CAAC,EAC7B,YAAY,CAAoD,sBAAsB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,EAC7G,OAAO,CACR,CAAC;AACN,MAAM,CAAC,MAAM,8BAA8B,GAAG,CAIxC,SAAuC,EACvC,OAAqE,EACrE,EAAE;IACJ,MAAM,KAAK,GAAG,YAAY,CAAoD,sBAAsB,CAAC,CAAA;IACrG,OAAO,gBAAgB,CACrB,CAAC,yBAAyB,EAAE,SAAS,CAAC,EACtC,CAAC,QAAQ,EAAE,EAAE,CAAC,KAAK,CAAC,EAAC,GAAG,SAAS,EAAE,GAAG,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE,CAAC,EAAC,CAAC,EAClE,OAAO,CACR,CAAA;AAAA,CAAC,CAAC;AAEP,MAAM,CAAC,MAAM,sBAAsB,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAqCjC,CAAC;AACN,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAIhC,SAAuC,EACvC,OAA6D,EAC7D,EAAE,CACJ,QAAQ,CACN,CAAC,gBAAgB,EAAE,SAAS,CAAC,EAC7B,YAAY,CAAoD,sBAAsB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,EAC7G,OAAO,CACR,CAAC;AACN,MAAM,CAAC,MAAM,8BAA8B,GAAG,CAIxC,SAAuC,EACvC,OAAqE,EACrE,EAAE;IACJ,MAAM,KAAK,GAAG,YAAY,CAAoD,sBAAsB,CAAC,CAAA;IACrG,OAAO,gBAAgB,CACrB,CAAC,yBAAyB,EAAE,SAAS,CAAC,EACtC,CAAC,QAAQ,EAAE,EAAE,CAAC,KAAK,CAAC,EAAC,GAAG,SAAS,EAAE,GAAG,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE,CAAC,EAAC,CAAC,EAClE,OAAO,CACR,CAAA;AAAA,CAAC,CAAC","sourcesContent":["import { useQuery, useInfiniteQuery, UseQueryOptions, UseInfiniteQueryOptions} from 'react-query';\nimport { useFetchData } from './fetcher';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Cursor: any;\n};\n\nexport type Erc20__Token = {\n  __typename?: 'ERC20__Token';\n  amount: Scalars['String'];\n  contractAddress: Scalars['String'];\n  decimals: Scalars['String'];\n  name: Scalars['String'];\n  symbol: Scalars['String'];\n};\n\nexport type Erc721__Token = {\n  __typename?: 'ERC721__Token';\n  contractAddress: Scalars['String'];\n  imagePath: Scalars['String'];\n  metadata: Scalars['String'];\n  metadataAttributes: Scalars['String'];\n  metadataDescription: Scalars['String'];\n  metadataName: Scalars['String'];\n  name: Scalars['String'];\n  symbol: Scalars['String'];\n  tokenId: Scalars['String'];\n};\n\nexport type Erc__Token = Erc20__Token | Erc721__Token;\n\nexport type Event = {\n  __typename?: 'Event';\n  edges: Array<EventEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type EventEdge = {\n  __typename?: 'EventEdge';\n  node: EventNode;\n};\n\nexport type EventNode = {\n  __typename?: 'EventNode';\n  createdAt: Scalars['String'];\n  data: Array<Scalars['String']>;\n  executedAt: Scalars['String'];\n  id: Scalars['String'];\n  keys: Array<Scalars['String']>;\n  transactionHash: Scalars['String'];\n};\n\nexport type PageInfo = {\n  __typename?: 'PageInfo';\n  hasNextPage: Scalars['Boolean'];\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  events?: Maybe<Array<Event>>;\n  tokenBalances: Token__BalanceConnection;\n  tokenTransfers?: Maybe<Token__TransferConnection>;\n};\n\n\nexport type QueryEventsArgs = {\n  keys: Array<Scalars['String']>;\n  limit: Scalars['Int'];\n  offset: Scalars['Int'];\n};\n\n\nexport type QueryTokenBalancesArgs = {\n  accountAddress: Scalars['String'];\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryTokenTransfersArgs = {\n  accountAddress: Scalars['String'];\n  after?: InputMaybe<Scalars['Cursor']>;\n  before?: InputMaybe<Scalars['Cursor']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n};\n\nexport type Token__Balance = {\n  __typename?: 'Token__Balance';\n  tokenMetadata: Erc__Token;\n};\n\nexport type Token__BalanceConnection = {\n  __typename?: 'Token__BalanceConnection';\n  edges: Array<Token__BalanceEdge>;\n  pageInfo: World__PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type Token__BalanceEdge = {\n  __typename?: 'Token__BalanceEdge';\n  cursor: Scalars['Cursor'];\n  node: Token__Balance;\n};\n\nexport type Token__Transfer = {\n  __typename?: 'Token__Transfer';\n  executedAt: Scalars['String'];\n  from: Scalars['String'];\n  to: Scalars['String'];\n  tokenMetadata: Erc__Token;\n  transactionHash: Scalars['String'];\n};\n\nexport type Token__TransferConnection = {\n  __typename?: 'Token__TransferConnection';\n  edges: Array<Token__TransferEdge>;\n  pageInfo: World__PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type Token__TransferEdge = {\n  __typename?: 'Token__TransferEdge';\n  cursor: Scalars['Cursor'];\n  node: Token__Transfer;\n};\n\nexport type World__PageInfo = {\n  __typename?: 'World__PageInfo';\n  endCursor?: Maybe<Scalars['Cursor']>;\n  hasNextPage: Scalars['Boolean'];\n  hasPreviousPage: Scalars['Boolean'];\n  startCursor?: Maybe<Scalars['Cursor']>;\n};\n\nexport type EventsQueryVariables = Exact<{\n  keys: Array<Scalars['String']> | Scalars['String'];\n  limit: Scalars['Int'];\n  offset: Scalars['Int'];\n}>;\n\n\nexport type EventsQuery = { __typename?: 'Query', events?: Array<{ __typename?: 'Event', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean }, edges: Array<{ __typename?: 'EventEdge', node: { __typename?: 'EventNode', id: string, keys: Array<string>, data: Array<string>, transactionHash: string, executedAt: string } }> }> | null };\n\nexport type Erc721BalancesQueryVariables = Exact<{\n  address: Scalars['String'];\n  limit: Scalars['Int'];\n  offset: Scalars['Int'];\n}>;\n\n\nexport type Erc721BalancesQuery = { __typename?: 'Query', tokenBalances: { __typename?: 'Token__BalanceConnection', edges: Array<{ __typename?: 'Token__BalanceEdge', node: { __typename?: 'Token__Balance', tokenMetadata: { __typename: 'ERC20__Token' } | { __typename: 'ERC721__Token', contractAddress: string, imagePath: string, metadata: string, metadataAttributes: string, metadataDescription: string, metadataName: string, name: string, tokenId: string } } }> } };\n\nexport type TokenTransfersQueryVariables = Exact<{\n  address: Scalars['String'];\n  first: Scalars['Int'];\n}>;\n\n\nexport type TokenTransfersQuery = { __typename?: 'Query', tokenTransfers?: { __typename?: 'Token__TransferConnection', edges: Array<{ __typename?: 'Token__TransferEdge', node: { __typename?: 'Token__Transfer', from: string, to: string, transactionHash: string, executedAt: string, tokenMetadata: { __typename: 'ERC20__Token', amount: string, contractAddress: string, decimals: string, name: string, symbol: string } | { __typename: 'ERC721__Token', contractAddress: string, imagePath: string, metadataAttributes: string, metadataDescription: string, metadataName: string, name: string, symbol: string, tokenId: string } } }>, pageInfo: { __typename?: 'World__PageInfo', hasNextPage: boolean, endCursor?: any | null } } | null };\n\n\nexport const EventsDocument = `\n    query Events($keys: [String!]!, $limit: Int!, $offset: Int!) {\n  events(keys: $keys, limit: $limit, offset: $offset) {\n    totalCount\n    pageInfo {\n      hasNextPage\n    }\n    edges {\n      node {\n        id\n        keys\n        data\n        transactionHash\n        executedAt\n      }\n    }\n  }\n}\n    `;\nexport const useEventsQuery = <\n      TData = EventsQuery,\n      TError = unknown\n    >(\n      variables: EventsQueryVariables,\n      options?: UseQueryOptions<EventsQuery, TError, TData>\n    ) =>\n    useQuery<EventsQuery, TError, TData>(\n      ['Events', variables],\n      useFetchData<EventsQuery, EventsQueryVariables>(EventsDocument).bind(null, variables),\n      options\n    );\nexport const useInfiniteEventsQuery = <\n      TData = EventsQuery,\n      TError = unknown\n    >(\n      variables: EventsQueryVariables,\n      options?: UseInfiniteQueryOptions<EventsQuery, TError, TData>\n    ) =>{\n    const query = useFetchData<EventsQuery, EventsQueryVariables>(EventsDocument)\n    return useInfiniteQuery<EventsQuery, TError, TData>(\n      ['Events.infinite', variables],\n      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),\n      options\n    )};\n\nexport const Erc721BalancesDocument = `\n    query ERC721Balances($address: String!, $limit: Int!, $offset: Int!) {\n  tokenBalances(accountAddress: $address, limit: $limit, offset: $offset) {\n    edges {\n      node {\n        tokenMetadata {\n          __typename\n          ... on ERC721__Token {\n            contractAddress\n            imagePath\n            metadata\n            metadataAttributes\n            metadataDescription\n            metadataName\n            name\n            tokenId\n          }\n        }\n      }\n    }\n  }\n}\n    `;\nexport const useErc721BalancesQuery = <\n      TData = Erc721BalancesQuery,\n      TError = unknown\n    >(\n      variables: Erc721BalancesQueryVariables,\n      options?: UseQueryOptions<Erc721BalancesQuery, TError, TData>\n    ) =>\n    useQuery<Erc721BalancesQuery, TError, TData>(\n      ['ERC721Balances', variables],\n      useFetchData<Erc721BalancesQuery, Erc721BalancesQueryVariables>(Erc721BalancesDocument).bind(null, variables),\n      options\n    );\nexport const useInfiniteErc721BalancesQuery = <\n      TData = Erc721BalancesQuery,\n      TError = unknown\n    >(\n      variables: Erc721BalancesQueryVariables,\n      options?: UseInfiniteQueryOptions<Erc721BalancesQuery, TError, TData>\n    ) =>{\n    const query = useFetchData<Erc721BalancesQuery, Erc721BalancesQueryVariables>(Erc721BalancesDocument)\n    return useInfiniteQuery<Erc721BalancesQuery, TError, TData>(\n      ['ERC721Balances.infinite', variables],\n      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),\n      options\n    )};\n\nexport const TokenTransfersDocument = `\n    query TokenTransfers($address: String!, $first: Int!) {\n  tokenTransfers(accountAddress: $address, first: $first) {\n    edges {\n      node {\n        from\n        to\n        tokenMetadata {\n          __typename\n          ... on ERC20__Token {\n            amount\n            contractAddress\n            decimals\n            name\n            symbol\n          }\n          ... on ERC721__Token {\n            contractAddress\n            imagePath\n            metadataAttributes\n            metadataDescription\n            metadataName\n            name\n            symbol\n            tokenId\n          }\n        }\n        transactionHash\n        executedAt\n      }\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n  }\n}\n    `;\nexport const useTokenTransfersQuery = <\n      TData = TokenTransfersQuery,\n      TError = unknown\n    >(\n      variables: TokenTransfersQueryVariables,\n      options?: UseQueryOptions<TokenTransfersQuery, TError, TData>\n    ) =>\n    useQuery<TokenTransfersQuery, TError, TData>(\n      ['TokenTransfers', variables],\n      useFetchData<TokenTransfersQuery, TokenTransfersQueryVariables>(TokenTransfersDocument).bind(null, variables),\n      options\n    );\nexport const useInfiniteTokenTransfersQuery = <\n      TData = TokenTransfersQuery,\n      TError = unknown\n    >(\n      variables: TokenTransfersQueryVariables,\n      options?: UseInfiniteQueryOptions<TokenTransfersQuery, TError, TData>\n    ) =>{\n    const query = useFetchData<TokenTransfersQuery, TokenTransfersQueryVariables>(TokenTransfersDocument)\n    return useInfiniteQuery<TokenTransfersQuery, TError, TData>(\n      ['TokenTransfers.infinite', variables],\n      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),\n      options\n    )};\n"]}